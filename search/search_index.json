{"config":{"lang":["pt"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#referencias","title":"Refer\u00eancias","text":"<ul> <li>http://www.riscbook.com/portuguese/</li> <li>https://riscv-programming.org/</li> <li>https://www.riscvschool.com/</li> </ul>"},{"location":"labs/","title":"Parte pr\u00e1tica","text":""},{"location":"labs/#simulacoes","title":"Simula\u00e7\u00f5es","text":"<p>Em geral, as simula\u00e7\u00f5es funcionais podem todas ser realizada em ambiente Linux. A seguir est\u00e1 o comando de instala\u00e7\u00e3o, dependendo de sua distribui\u00e7\u00e3o, dos pacotes necess\u00e1rios: <code>[apt|snap|yum|rpm|dnf|pacman] install iverilog gtkwave gcc-riscv64-linux-gnu binutils-riscv64-linux-gnu qemu-user qemu-user-static</code></p>"},{"location":"labs/#extensoes-uteis-para-o-vscode","title":"Extens\u00f5es \u00fateis para o VSCode","text":"<ul> <li>Verilog</li> <li>WaveTrave</li> <li>DigitalJS</li> <li>RISCV</li> </ul>"},{"location":"labs/#kit-de-fpga","title":"Kit de FPGA","text":"<p>Para sintetizar cada laborat\u00f3rio e fazer o download para a placa, digite <code>..\\make_wannabe.bat</code> (Windows) ou <code>make -f ../Makefile</code> (Linux) dentro do diret\u00f3rio do respectivo laborat\u00f3rio (n\u00e3o nesta pasta, pois os comandos fazem refer\u00eancia ao n\u00edvel superior). </p>"},{"location":"labs/#de0-cv","title":"DE0-CV","text":"<p>Consulte o manual do kit para compreender como usar cada recurso. Um arquivo de pinos \u00e9 usado para mapear as entradas e sa\u00eddas.</p>"},{"location":"labs/01-banner/","title":"Criando um banner no kit de FPGAs","text":"<p>Se voc\u00ea n\u00e3o se lembra de como usar o kit de FPGAs e as ferramentas, d\u00ea uma olhada neste laborat\u00f3rio.</p> <p>O objetivo desta pr\u00e1tica \u00e9 usar uma mem\u00f3ria ROM para criar um efeito visual que simule um banner nos LEDs do kit. O conte\u00fado da mem\u00f3ria \u00e9 exibido nos LEDs uma linha por vez, o que visto rapidamente, em movimento ou filmado pode revelar seu conte\u00fado completo se usada a frequ\u00eancia correta. </p> <p>Os arquivos est\u00e3o todos completos, voc\u00ea s\u00f3 precisa modificar o conte\u00fado da mem\u00f3ria para exibir o que desejar e variar a frequ\u00eacia at\u00e9 encontrar uma que seja poss\u00edvel ver o banner. </p> <p></p>"},{"location":"labs/02-decode-game/","title":"Decodificando instru\u00e7\u00f5es do RISC-V","text":"<p>O objetivo desta pr\u00e1tica \u00e9 construir um jogo para compreender a codifica\u00e7\u00e3o de instru\u00e7\u00f5es e c\u00e1lculos de endere\u00e7o no RISC-V. Ele pode ser feito em qualquer linguagem de sua prefer\u00eancia, usando ou n\u00e3o o kit de FPGAs. A partir de um programa fornecido ou gerado aleat\u00f3riamente, o jogador precisa adivinhar partes das instru\u00e7\u00f5es ou endere\u00e7os para ganhar pontos ou avan\u00e7ar no jogo. A seguir est\u00e1 um fluxo poss\u00edvel: </p> <pre><code>flowchart TD\n    Start([\"Escolha Instru\u00e7\u00e3o\"])\n    Opcode[\"Adivinhar OPCODE (7 bits)\"]\n    Format{\"Formato?\"}\n    NextInstr([\"Pr\u00f3xima Instru\u00e7\u00e3o\"])\n\n    Start --&gt; Opcode\n    Opcode --&gt; Format\n\n    %% R-Type\n    Format --&gt; RType([\"R-Type\"])\n    RType --&gt; R_rd[\"Adivinhar rd (5)\"]\n    R_rd --&gt; R_funct3[\"Adivinhar funct3 (3)\"]\n    R_funct3 --&gt; R_rs1[\"Adivinhar rs1 (5)\"]\n    R_rs1 --&gt; R_rs2[\"Adivinhar rs2 (5)\"]\n    R_rs2 --&gt; R_funct7[\"Adivinhar funct7 (7)\"]\n    R_funct7 --&gt; NextInstr\n\n    %% I-Type\n    Format --&gt; IType([\"I-Type\"])\n    IType --&gt; I_rd[\"Adivinhar rd (5)\"]\n    I_rd --&gt; I_funct3[\"Adivinhar funct3 (3)\"]\n    I_funct3 --&gt; I_rs1[\"Adivinhar rs1 (5)\"]\n    I_rs1 --&gt; I_imm[\"Adivinhar imm (12)\"]\n    I_imm --&gt; NextInstr\n\n    %% S-Type\n    Format --&gt; SType([\"S-Type\"])\n    SType --&gt; S_funct3[\"Adivinhar funct3 (3)\"]\n    S_funct3 --&gt; S_rs1[\"Adivinhar rs1 (5)\"]\n    S_rs1 --&gt; S_rs2[\"Adivinhar rs2 (5)\"]\n    S_rs2 --&gt; S_imm[\"Adivinhar imm (12, encoded)\"]\n    S_imm --&gt; NextInstr\n\n    %% B-Type\n    Format --&gt; BType([\"B-Type\"])\n    BType --&gt; B_funct3[\"Adivinhar funct3 (3)\"]\n    B_funct3 --&gt; B_rs1[\"Adivinhar rs1 (5)\"]\n    B_rs1 --&gt; B_rs2[\"Adivinhar rs2 (5)\"]\n    B_rs2 --&gt; B_imm[\"Adivinhar imm (13, encoded)\"]\n    B_imm --&gt; NextInstr\n\n    %% U-Type\n    Format --&gt; UType([\"U-Type\"])\n    UType --&gt; U_rd[\"Adivinhar rd (5)\"]\n    U_rd --&gt; U_imm[\"Adivinhar imm (20)\"]\n    U_imm --&gt; NextInstr\n\n    %% J-Type\n    Format --&gt; JType([\"J-Type\"])\n    JType --&gt; J_rd[\"Adivinhar rd (5)\"]\n    J_rd --&gt; J_imm[\"Adivinhar imm (21, encoded)\"]\n    J_imm --&gt; NextInstr\n\n    %% STYLE DEFINITIONS\nclassDef Adivinhar fill:#cce5ff,stroke:#004085,stroke-width:2px;\n    class Opcode,R_rd,R_funct3,R_rs1,R_rs2,R_funct7,I_rd,I_funct3,I_rs1,I_imm,S_funct3,S_rs1,S_rs2,S_imm,B_funct3,B_rs1,B_rs2,B_imm,U_rd,U_imm,J_rd,J_imm Adivinhar;\n</code></pre> <p>Todas as jogadas devem ser informadas em bin\u00e1rio na console!</p> <p>Procure usar programas com instru\u00e7\u00f5es bem diversas, por exemplo:</p> <pre><code>_start:\n    # R-type: registradores\n    add     x5, x1, x2         # R: rd=x5, rs1=x1, rs2=x2, funct3=000, funct7=0000000\n    xor     x4, x2, x3         # R: rd=x4, rs1=x2, rs2=x3, funct3=100, funct7=0000000\n    # I-type (aritm\u00e9tico imediato)\n    addi    x6, x5, 42         # I: rd=x6, rs1=x5, imm=42, funct3=000\n    slli    x5, x6, 3          # I: rd=x5, rs1=x6, shamt=3, funct3=001\n    # I-type (load)\n    lw      x7, 64(x6)          # I: rd=x7, rs1=x6, imm=64, funct3=010\n    lbu     x5, 32(x4)          # I: rd=x5, rs1=x4, imm=32, funct3=100\n    # S-type: store\n    sw      x7, 16(x5)         # S: rs1=x5, rs2=x7, imm=16, funct3=010\n    sb      x6, 16(x2)         # S: rs1=x2, rs2=x6, imm=16, funct3=001\n    # B-type: branch condicional\n    beq     x5, x6, label      # B: rs1=x5, rs2=x6, imm=offset(label), funct3=000\n    bne     x3, x4, label      # B: rs1=x3, rs2=x4, imm=offset(label), funct3=001\n    # U-type: imediato alto\n    lui     x8, 0xABCDE        # U: rd=x8, imm[31:12]=0xABCDE\n    # J-type: salto\n    jal     x1, end            # J: rd=x1 (ra), imm=offset(end)\nlabel:\n    addi    x9, x0, 7          # I: instru\u00e7\u00e3o ap\u00f3s branch\nend:\n    nop                        # I-type: addi x0,x0,0\n</code></pre> <p>Para garantir que as codifica\u00e7\u00f5es est\u00e3o corretas, seu programa deve invocar o GCC para ger\u00e1-la automaticamente. </p> <p>Depois voc\u00ea pode extrair os campos e gerar tabelas como a seguinte:</p> Instr. Opcode rd funct3 rs1 rs2 funct7 imm (decimal/hex) xor x5,x1,x2 0110011 5 100 1 2 0000000 - slli x6,x5,3 0010011 6 001 5 - 0000000 shamt=3 lbu x7,8(x6) 0000011 7 100 6 - - 8 sb x7,16(x5) 0100011 - 001 5 7 - 16 bne x5,x6,label 1100011 - 001 5 6 - offset(label)=calculado lui x8,0xABCDE 0110111 8 - - - - 0xABCDE jal x1,end 1101111 1 - - - - offset(end)=calculado addi x9,x0,7 0010011 9 000 0 - - 7 nop 0010011 0 000 0 - - 0 <p>O jogo deve executar em sistemas Linux apenas no modo console. Incluir coment\u00e1rios no c\u00f3digo fonte e depend\u00eancias necess\u00e1rias para sua execu\u00e7\u00e3o. </p> <p>Um programa de refer\u00eancia foi fornecido, observe os arquivos que ele manipula para entender cada passo. Para test\u00e1-lo, basta digitar <code>make</code> no terminal. </p>"},{"location":"labs/02-decode-game/#referencias","title":"Refer\u00eancias:","text":"<ul> <li>The RISC-V Instruction Set Manual Volume I: Unprivileged ISA, pg. 608</li> <li>From Blinker to RISC-V</li> </ul>"}]}